#include "pkg/lock_file.h"

#include "toml++/toml.hpp"

#include <filesystem>
#include <fstream>

namespace fs = std::filesystem;

namespace zo {

std::optional<LockFile> LockFile::load(const std::string& dir) {
    fs::path path = fs::path(dir) / "zo.lock";
    if (!fs::exists(path)) return std::nullopt;

    try {
        auto result = toml::parse_file(path.string());

        LockFile lock;

        if (auto arr = result["dependencies"].as_array()) {
            for (const auto& elem : *arr) {
                if (auto tbl = elem.as_table()) {
                    LockedDependency dep;
                    dep.name = (*tbl)["name"].value_or(std::string(""));
                    dep.git = (*tbl)["git"].value_or(std::string(""));
                    dep.version = (*tbl)["version"].value_or(std::string(""));
                    dep.commit = (*tbl)["commit"].value_or(std::string(""));
                    lock.dependencies.push_back(std::move(dep));
                }
            }
        }

        return lock;
    } catch (const toml::parse_error&) {
        return std::nullopt;
    }
}

bool LockFile::save(const std::string& dir) const {
    fs::path path = fs::path(dir) / "zo.lock";

    std::ofstream out(path);
    if (!out) return false;

    out << "# auto-generated by zo â€” do not edit\n\n";

    for (const auto& dep : dependencies) {
        out << "[[dependencies]]\n"
            << "name = \"" << dep.name << "\"\n"
            << "git = \"" << dep.git << "\"\n"
            << "version = \"" << dep.version << "\"\n"
            << "commit = \"" << dep.commit << "\"\n"
            << "\n";
    }

    return out.good();
}

const LockedDependency* LockFile::find(const std::string& name) const {
    for (const auto& dep : dependencies) {
        if (dep.name == name) return &dep;
    }
    return nullptr;
}

void LockFile::setDependency(const LockedDependency& dep) {
    for (auto& existing : dependencies) {
        if (existing.name == dep.name) {
            existing = dep;
            return;
        }
    }
    dependencies.push_back(dep);
}

} // namespace zo
